<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Batch Job Processing - UML Workflow Diagrams</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            padding: 2rem;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 3rem;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.95;
        }

        .nav {
            background: #f8f9fa;
            padding: 1.5rem;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .nav button {
            padding: 0.75rem 1.5rem;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .nav button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .nav button.active {
            background: #764ba2;
            box-shadow: 0 4px 12px rgba(118, 75, 162, 0.4);
        }

        .content {
            padding: 3rem;
        }

        .diagram-section {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .diagram-section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .diagram-container {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 2rem;
            margin: 2rem 0;
            border: 2px solid #e9ecef;
            overflow-x: auto;
        }

        .diagram-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #667eea;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #667eea;
        }

        .diagram-description {
            background: #e7f3ff;
            border-left: 4px solid #667eea;
            padding: 1rem;
            margin-bottom: 1.5rem;
            border-radius: 4px;
        }

        .legend {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }

        .legend h3 {
            color: #667eea;
            margin-bottom: 1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin: 0.5rem 0;
        }

        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 1.5rem;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
            margin: 1rem 0;
        }

        .code-keyword { color: #569cd6; }
        .code-string { color: #ce9178; }
        .code-comment { color: #6a9955; }
        .code-class { color: #4ec9b0; }
        .code-function { color: #dcdcaa; }

        .info-box {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 1.5rem;
            margin: 2rem 0;
        }

        .info-box h3 {
            color: #667eea;
            margin-bottom: 1rem;
        }

        .info-box ul {
            margin-left: 1.5rem;
        }

        .info-box li {
            margin: 0.5rem 0;
        }

        .mermaid {
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä Batch Job Processing Workflow</h1>
            <p>Complete UML Diagrams - From Trigger to Completion</p>
        </div>

        <div class="nav">
            <button onclick="showDiagram('sequence')" class="active">Sequence Diagram</button>
            <button onclick="showDiagram('state')">State Machine</button>
            <button onclick="showDiagram('component')">Component Diagram</button>
            <button onclick="showDiagram('activity')">Activity Diagram</button>
            <button onclick="showDiagram('overview')">Overview</button>
        </div>

        <div class="content">
            <!-- Sequence Diagram -->
            <div id="sequence" class="diagram-section active">
                <div class="diagram-title">üìã Sequence Diagram: Complete Batch Job Workflow</div>
                <div class="diagram-description">
                    <strong>Complete flow from job creation to delivery:</strong> Shows all interactions between components from the initial trigger (scheduled/manual) through processing, data fetching, field masking, and final delivery.
                </div>
                <div class="diagram-container">
                    <div class="mermaid">
sequenceDiagram
    participant Trigger as ‚è∞ Trigger<br/>(Scheduled/Manual)
    participant SRS as ScheduledReportService
    participant JQS as JobQueueService
    participant DB as PostgreSQL<br/>(report_jobs)
    participant BJS as BatchJobScheduler
    participant BPS as BackgroundProcessingService
    participant RGS as ReportGenerationService
    participant QBS as QueryBuilderService
    participant DFS as DataFetchingService
    participant FMS as FieldMaskingService
    participant Delivery as üìßüìÅ Delivery<br/>(Email/SFTP/API)

    Note over Trigger,Delivery: üöÄ PHASE 1: Job Creation & Queuing
    
    alt Scheduled Trigger (Cron)
        Trigger->>SRS: @Scheduled cron fires<br/>(Daily 5:30 AM / Weekly Monday)
        SRS->>SRS: Generate JWT token<br/>for profile/county
        SRS->>SRS: Create BIReportRequest<br/>(role, type, county, dates)
        SRS->>JQS: queueReportJob(request, jwtToken)
    else Manual Trigger (API)
        Trigger->>JQS: POST /api/pipeline/generate-report<br/>(with JWT in header)
        JQS->>JQS: Extract user info from JWT<br/>(role, countyId)
        JQS->>JQS: Create BIReportRequest<br/>from request body
        JQS->>JQS: queueReportJob(request, jwtToken)
    end

    JQS->>JQS: Generate unique JobID<br/>(JOB_XXXXXXXX)
    JQS->>JQS: Create ReportJobEntity<br/>(status=QUEUED, priority, dates)
    JQS->>DB: save(jobEntity)
    JQS-->>Trigger: Return jobId
    
    Note over BJS,Delivery: üîÑ PHASE 2: Job Polling & Dispatch
    
    loop Every 5 seconds
        BJS->>BJS: @Scheduled pollAndDispatchJobs()
        BJS->>DB: findTopQueuedJobs(maxJobsPerPoll)<br/>(ORDER BY priority DESC, created_at ASC)
        DB-->>BJS: List&lt;ReportJobEntity&gt; queuedJobs
        
        loop For each queued job
            BJS->>JQS: markJobAsProcessing(jobId)
            JQS->>DB: UPDATE status='PROCESSING'<br/>SET started_at=NOW()
            DB-->>JQS: Job updated
            JQS-->>BJS: Optional&lt;ReportJobEntity&gt; claimedJob
            BJS->>BPS: execute(() -> processJob(jobId))
        end
    end

    Note over BPS,Delivery: ‚öôÔ∏è PHASE 3: Background Processing
    
    BPS->>DB: findByJobId(jobId)
    DB-->>BPS: ReportJobEntity job
    BPS->>JQS: deserializeRequest(job)
    JQS-->>BPS: BIReportRequest originalRequest
    BPS->>BPS: Extract JWT token from job
    BPS->>BPS: Parse JWT to extract<br/>(userRole, countyId)
    BPS->>BPS: createExtractionRequest(job, request, role, county)
    
    Note over BPS,DFS: üìä PHASE 4: Data Processing (Chunked)
    
    BPS->>BPS: estimateTotalRecords(request)
    BPS->>DB: UPDATE total_records
    BPS->>BPS: processDataInChunksStreaming()
    
    loop For each chunk (page 0, 1, 2...)
        BPS->>BPS: Check if job CANCELLED
        alt Job Cancelled
            BPS->>BPS: Delete partial file<br/>Throw RuntimeException
        end
        
        BPS->>BPS: processChunkWithRetry(request, page, chunkSize, jwtToken)
        BPS->>RGS: generateReportChunk(reportRequest, jwtToken)
        RGS->>QBS: buildQuery(userRole, county, dates, page, pageSize)
        QBS-->>RGS: SQL query with pagination
        RGS->>DFS: fetchData(queryParams)
        DFS->>DB: Execute paginated query<br/>(LIMIT/OFFSET)
        DB-->>DFS: List&lt;TimesheetEntity&gt; rawData
        DFS-->>RGS: DataFetchResult
        RGS->>FMS: applyFieldMasking(data, userRole, jwtToken)
        FMS->>FMS: Get masking rules for role
        FMS->>FMS: Apply masking (HIDDEN, PARTIAL, HASH, etc.)
        FMS-->>RGS: List&lt;MaskedTimesheetData&gt;
        RGS-->>BPS: Chunk data (masked)
        
        alt Format = PDF
            BPS->>BPS: Collect all chunks in memory
        else Format = JSON/CSV/XML
            BPS->>BPS: Write chunk directly to file<br/>(streaming, no memory accumulation)
        end
        
        BPS->>JQS: updateJobProgress(jobId, processed, total)
        JQS->>DB: UPDATE progress, processed_records
    end
    
    alt Format = PDF
        BPS->>BPS: Generate PDF with all collected data
        BPS->>BPS: Save PDF to file
    else Format = JSON/CSV/XML
        BPS->>BPS: Write file footer
        BPS->>BPS: Close file writer
    end

    Note over BPS,Delivery: ‚úÖ PHASE 5: Job Completion
    
    BPS->>JQS: setJobResult(jobId, filePath)
    JQS->>DB: UPDATE status='COMPLETED'<br/>SET result_path, completed_at<br/>SET progress=100
    DB-->>JQS: Job updated
    JQS-->>BPS: Success
    
    BPS->>BPS: triggerDependentJobs(job, jwtToken)
    alt Has Dependencies
        BPS->>BPS: JobDependencyService.triggerDependentJobs()
        BPS->>JQS: queueReportJob(dependentRequest, jwtToken, parentJobId)
        JQS->>DB: Save dependent job<br/>(parent_job_id set)
    end

    Note over Delivery: üì§ PHASE 6: Delivery (Optional)
    
    alt Email Delivery (if enabled)
        Delivery->>Delivery: EmailReportService.sendScheduledReportEmail()
        Delivery->>Delivery: Generate PDF attachment
        Delivery->>Delivery: Send via SMTP (MailHog)
    else SFTP Delivery (if enabled)
        Delivery->>Delivery: SFTPDeliveryService.deliverFile()
        Delivery->>Delivery: Encrypt CSV file
        Delivery->>Delivery: Upload to SFTP server
    else API Response
        Delivery->>Delivery: Return JSON with download link
    end
                    </div>
                </div>

                <div class="legend">
                    <h3>üìå Key Components</h3>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #667eea;"></div>
                        <span><strong>ScheduledReportService:</strong> Triggers jobs via cron schedules (Daily 5:30 AM, Weekly Monday)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #764ba2;"></div>
                        <span><strong>JobQueueService:</strong> Manages job lifecycle (QUEUED ‚Üí PROCESSING ‚Üí COMPLETED)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f093fb;"></div>
                        <span><strong>BatchJobScheduler:</strong> Polls database every 5 seconds for QUEUED jobs</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4facfe;"></div>
                        <span><strong>BackgroundProcessingService:</strong> Processes jobs asynchronously in chunks</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #43e97b;"></div>
                        <span><strong>ReportGenerationService:</strong> Orchestrates data fetching and field masking</span>
                    </div>
                </div>
            </div>

            <!-- State Machine Diagram -->
            <div id="state" class="diagram-section">
                <div class="diagram-title">üîÑ State Machine: Job Lifecycle</div>
                <div class="diagram-description">
                    <strong>Job state transitions:</strong> Shows how a job moves through different states from creation to final completion or failure.
                </div>
                <div class="diagram-container">
                    <div class="mermaid">
stateDiagram-v2
    [*] --> QUEUED: Job Created<br/>(queueReportJob)
    
    QUEUED: Status: QUEUED<br/>Priority: 1-10<br/>Created At: NOW()
    QUEUED: Stored in PostgreSQL<br/>report_jobs table
    QUEUED: Waiting for scheduler<br/>to claim
    
    QUEUED --> PROCESSING: BatchJobScheduler<br/>claims job<br/>(markJobAsProcessing)
    QUEUED --> CANCELLED: User cancels<br/>(cancelJob)
    QUEUED --> FAILED: Validation error<br/>(invalid request)
    
    PROCESSING: Status: PROCESSING<br/>Started At: NOW()<br/>Progress: 0-99%
    PROCESSING: BackgroundProcessingService<br/>processing chunks
    PROCESSING: Updating progress<br/>every chunk
    
    PROCESSING --> COMPLETED: All chunks processed<br/>Result saved<br/>(setJobResult)
    PROCESSING --> FAILED: Exception thrown<br/>(updateJobStatus FAILED)
    PROCESSING --> CANCELLED: User cancels<br/>during processing
    
    COMPLETED: Status: COMPLETED<br/>Progress: 100%<br/>Completed At: NOW()
    COMPLETED: Result Path: file path<br/>Total Records: count
    COMPLETED: Dependent jobs<br/>may be triggered
    
    COMPLETED --> [*]: Job finished
    
    FAILED: Status: FAILED<br/>Error Message: details<br/>Completed At: NOW()
    FAILED: Error logged<br/>No result generated
    
    FAILED --> [*]: Job terminated
    
    CANCELLED: Status: CANCELLED<br/>Completed At: NOW()
    CANCELLED: Partial file deleted<br/>(if exists)
    
    CANCELLED --> [*]: Job terminated
    
    note right of QUEUED
        Job stored in database
        with priority and metadata
        Scheduler polls every 5s
    end note
    
    note right of PROCESSING
        Chunked processing:
        - Fetch data in pages
        - Apply field masking
        - Write to file (streaming)
        - Update progress
    end note
    
    note right of COMPLETED
        Result file saved:
        - JSON: /reports/{jobId}.json
        - CSV: /reports/{jobId}.csv
        - PDF: /reports/{jobId}.pdf
    end note
                    </div>
                </div>

                <div class="info-box">
                    <h3>üìä Job States Explained</h3>
                    <ul>
                        <li><strong>QUEUED:</strong> Job created and waiting in database. Scheduler polls every 5 seconds.</li>
                        <li><strong>PROCESSING:</strong> Job claimed by scheduler, being processed in background thread. Progress updated incrementally.</li>
                        <li><strong>COMPLETED:</strong> All data processed, result file saved, progress = 100%. Dependent jobs may be triggered.</li>
                        <li><strong>FAILED:</strong> Exception occurred during processing. Error message stored for debugging.</li>
                        <li><strong>CANCELLED:</strong> User manually cancelled job. Partial files are deleted.</li>
                    </ul>
                </div>
            </div>

            <!-- Component Diagram -->
            <div id="component" class="diagram-section">
                <div class="diagram-title">üèóÔ∏è Component Architecture Diagram</div>
                <div class="diagram-description">
                    <strong>Service relationships and dependencies:</strong> Shows how all services interact and depend on each other.
                </div>
                <div class="diagram-container">
                    <div class="mermaid">
graph TB
    subgraph "üéØ Triggers"
        CRON[ScheduledReportService<br/>@Scheduled cron]
        API[DataPipelineController<br/>POST /generate-report]
        BI[BusinessIntelligenceController<br/>POST /bi/reports]
    end

    subgraph "üìã Job Management"
        JQS[JobQueueService<br/>- queueReportJob<br/>- markJobAsProcessing<br/>- updateJobStatus<br/>- setJobResult]
        BJS[BatchJobScheduler<br/>@Scheduled every 5s<br/>- pollAndDispatchJobs]
    end

    subgraph "‚öôÔ∏è Processing"
        BPS[BackgroundProcessingService<br/>- processJob<br/>- processDataInChunksStreaming<br/>- processChunkWithRetry]
        RGS[ReportGenerationService<br/>- generateReport<br/>- generateReportChunk]
    end

    subgraph "üîç Data Layer"
        QBS[QueryBuilderService<br/>- buildQuery<br/>- applyFilters]
        DFS[DataFetchingService<br/>- fetchData<br/>- executeQuery]
        REPO[TimesheetRepository<br/>- findByDateRange<br/>- findByLocation]
    end

    subgraph "üîê Security & Masking"
        FMS[FieldMaskingService<br/>- applyFieldMasking<br/>- getMaskingRules]
        FVS[FieldVisibilityService<br/>- isFieldVisible]
    end

    subgraph "üì§ Delivery"
        EMAIL[EmailReportService<br/>- sendScheduledReportEmail<br/>- generatePDF]
        SFTP[SFTPDeliveryService<br/>- deliverFile<br/>- encryptFile]
        PDF[PDFReportGeneratorService<br/>- generatePDFReport]
    end

    subgraph "üóÑÔ∏è Database"
        DB[(PostgreSQL<br/>report_jobs<br/>timesheets)]
    end

    subgraph "üîó Dependencies"
        JDS[JobDependencyService<br/>- triggerDependentJobs]
    end

    CRON --> JQS
    API --> JQS
    BI --> JQS
    
    JQS --> DB
    BJS --> JQS
    BJS --> BPS
    
    BPS --> RGS
    BPS --> JQS
    BPS --> JDS
    
    RGS --> QBS
    RGS --> DFS
    RGS --> FMS
    
    QBS --> REPO
    DFS --> REPO
    REPO --> DB
    
    FMS --> FVS
    
    BPS --> EMAIL
    BPS --> SFTP
    EMAIL --> PDF
    
    style CRON fill:#667eea,color:#fff
    style API fill:#667eea,color:#fff
    style JQS fill:#764ba2,color:#fff
    style BJS fill:#f093fb,color:#fff
    style BPS fill:#4facfe,color:#fff
    style RGS fill:#43e97b,color:#fff
    style DB fill:#ff6b6b,color:#fff
                    </div>
                </div>

                <div class="info-box">
                    <h3>üîó Service Dependencies</h3>
                    <ul>
                        <li><strong>JobQueueService</strong> is the central coordinator - all triggers create jobs through it</li>
                        <li><strong>BatchJobScheduler</strong> depends on JobQueueService to find and claim jobs</li>
                        <li><strong>BackgroundProcessingService</strong> orchestrates the entire processing pipeline</li>
                        <li><strong>ReportGenerationService</strong> handles data fetching and masking coordination</li>
                        <li><strong>QueryBuilderService</strong> and <strong>DataFetchingService</strong> work together to fetch paginated data</li>
                        <li><strong>FieldMaskingService</strong> applies role-based field visibility rules</li>
                    </ul>
                </div>
            </div>

            <!-- Activity Diagram -->
            <div id="activity" class="diagram-section">
                <div class="diagram-title">üéØ Activity Diagram: Job Processing Flow</div>
                <div class="diagram-description">
                    <strong>Detailed processing steps:</strong> Shows the step-by-step activities within the BackgroundProcessingService when processing a job.
                </div>
                <div class="diagram-container">
                    <div class="mermaid">
flowchart TD
    Start([Job Claimed by Scheduler]) --> LoadJob[Load ReportJobEntity<br/>from Database]
    LoadJob --> Deserialize[Deserialize Request Data<br/>BIReportRequest]
    Deserialize --> ExtractJWT[Extract JWT Token<br/>from job.jwtToken]
    ExtractJWT --> ParseJWT[Parse JWT to extract<br/>userRole, countyId]
    ParseJWT --> CreateRequest[Create PipelineExtractionRequest<br/>with role, county, dates]
    
    CreateRequest --> EstimateTotal[Estimate Total Records<br/>from database]
    EstimateTotal --> UpdateTotal[Update job.totalRecords<br/>in database]
    UpdateTotal --> CheckFormat{Data Format?}
    
    CheckFormat -->|PDF| CollectPDF[Collect all chunks<br/>in memory]
    CheckFormat -->|JSON/CSV/XML| StreamFile[Open file writer<br/>for streaming]
    
    StreamFile --> WriteHeader[Write file header]
    CollectPDF --> ChunkLoop[Start chunk loop]
    WriteHeader --> ChunkLoop
    
    ChunkLoop --> CheckCancelled{Job<br/>Cancelled?}
    CheckCancelled -->|Yes| DeleteFile[Delete partial file<br/>Throw exception]
    CheckCancelled -->|No| FetchChunk[Fetch chunk from DB<br/>page, pageSize]
    
    FetchChunk --> BuildQuery[QueryBuilderService<br/>buildQuery with pagination]
    BuildQuery --> ExecuteQuery[Execute SQL query<br/>LIMIT/OFFSET]
    ExecuteQuery --> GetRawData[Get raw TimesheetEntity<br/>records]
    GetRawData --> ApplyMasking[FieldMaskingService<br/>applyFieldMasking]
    ApplyMasking --> GetMaskedData[Get MaskedTimesheetData<br/>with visibility rules]
    
    GetMaskedData --> CheckFormat2{Format?}
    CheckFormat2 -->|PDF| AddToMemory[Add chunk to<br/>memory collection]
    CheckFormat2 -->|JSON/CSV/XML| WriteChunk[Write chunk<br/>directly to file]
    
    AddToMemory --> UpdateProgress[Update job progress<br/>processed/total]
    WriteChunk --> UpdateProgress
    UpdateProgress --> CheckMore{More<br/>chunks?}
    
    CheckMore -->|Yes| ChunkLoop
    CheckMore -->|No| Finalize{Format?}
    
    Finalize -->|PDF| GeneratePDF[Generate PDF<br/>with all data]
    Finalize -->|JSON/CSV/XML| WriteFooter[Write file footer<br/>Close writer]
    
    GeneratePDF --> SavePDF[Save PDF file]
    WriteFooter --> SaveFile[File saved]
    SavePDF --> SaveFile
    
    SaveFile --> SetResult[JobQueueService<br/>setJobResult jobId, filePath]
    SetResult --> UpdateStatus[Update status=COMPLETED<br/>progress=100%<br/>completed_at=NOW]
    UpdateStatus --> CheckDeps{Has<br/>Dependencies?}
    
    CheckDeps -->|Yes| TriggerDeps[JobDependencyService<br/>triggerDependentJobs]
    CheckDeps -->|No| End([Job Complete])
    TriggerDeps --> QueueDeps[Queue dependent jobs<br/>with parentJobId]
    QueueDeps --> End
    
    DeleteFile --> FailStatus[Update status=FAILED<br/>error_message set]
    FailStatus --> EndFail([Job Failed])
    
    style Start fill:#667eea,color:#fff
    style End fill:#43e97b,color:#fff
    style EndFail fill:#ff6b6b,color:#fff
    style ChunkLoop fill:#f093fb,color:#fff
    style ApplyMasking fill:#4facfe,color:#fff
                    </div>
                </div>

                <div class="info-box">
                    <h3>‚ö° Key Processing Features</h3>
                    <ul>
                        <li><strong>Chunked Processing:</strong> Data is fetched in pages (default 1000 records) to prevent memory issues</li>
                        <li><strong>Streaming File Writing:</strong> JSON/CSV/XML formats write chunks directly to file (no memory accumulation)</li>
                        <li><strong>PDF Collection:</strong> PDF format requires all data in memory, so chunks are collected first</li>
                        <li><strong>Progress Tracking:</strong> Progress updated after each chunk (processed/total records)</li>
                        <li><strong>Cancellation Support:</strong> Job can be cancelled at any time, partial files are deleted</li>
                        <li><strong>Retry Mechanism:</strong> Chunk processing has 3 retry attempts with exponential backoff</li>
                        <li><strong>Dependent Jobs:</strong> After completion, dependent jobs are automatically triggered</li>
                    </ul>
                </div>
            </div>

            <!-- Overview -->
            <div id="overview" class="diagram-section">
                <div class="diagram-title">üìñ Complete Workflow Overview</div>
                <div class="diagram-description">
                    <strong>High-level summary:</strong> Complete overview of the batch job processing system from all perspectives.
                </div>

                <div class="info-box">
                    <h3>üöÄ Trigger Mechanisms</h3>
                    <ul>
                        <li><strong>Scheduled Reports (Cron):</strong>
                            <ul>
                                <li>Daily: 5:30 AM IST - All role profiles (ADMIN, SUPERVISOR, CASE_WORKER_CT1-5)</li>
                                <li>Weekly: Monday 5:30 AM IST - ADMIN only</li>
                                <li>Monthly: 1st of month 5:30 AM IST - All roles</li>
                                <li>Quarterly: 1st of quarter 5:30 AM IST - ADMIN only</li>
                                <li>Yearly: January 1st 5:30 AM IST - ADMIN only</li>
                                <li>SYSTEM_SCHEDULER: Every 5 minutes - County-specific reports</li>
                            </ul>
                        </li>
                        <li><strong>Manual API Requests:</strong>
                            <ul>
                                <li>POST /api/pipeline/generate-report - User-initiated report generation</li>
                                <li>POST /api/bi/reports - Business Intelligence report requests</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="info-box">
                    <h3>üìä Job Processing Pipeline</h3>
                    <ol>
                        <li><strong>Job Creation:</strong> JobQueueService creates ReportJobEntity with status=QUEUED</li>
                        <li><strong>Job Polling:</strong> BatchJobScheduler polls every 5 seconds, finds QUEUED jobs by priority</li>
                        <li><strong>Job Claiming:</strong> Scheduler marks job as PROCESSING and dispatches to BackgroundProcessingService</li>
                        <li><strong>Data Extraction:</strong> QueryBuilderService builds SQL, DataFetchingService executes with pagination</li>
                        <li><strong>Field Masking:</strong> FieldMaskingService applies role-based visibility rules (HIDDEN, PARTIAL, HASH, etc.)</li>
                        <li><strong>Chunk Processing:</strong> Data processed in chunks (default 1000 records), written to file incrementally</li>
                        <li><strong>Progress Updates:</strong> Progress updated after each chunk (processed/total records)</li>
                        <li><strong>Job Completion:</strong> Status set to COMPLETED, result path saved, progress = 100%</li>
                        <li><strong>Dependent Jobs:</strong> If configured, dependent jobs are automatically queued</li>
                        <li><strong>Delivery:</strong> Optional email (PDF) or SFTP (encrypted CSV) delivery</li>
                    </ol>
                </div>

                <div class="info-box">
                    <h3>üîê Security & Access Control</h3>
                    <ul>
                        <li><strong>JWT Token Required:</strong> All jobs must include valid JWT token (no fallback)</li>
                        <li><strong>Role Extraction:</strong> Role extracted from JWT (resource_access.trial-app.roles or realm_access.roles)</li>
                        <li><strong>County Filtering:</strong> County extracted from JWT (countyId or county_id in attributes)</li>
                        <li><strong>Field Masking:</strong> Fields masked based on user role (6 masking types: NONE, HIDDEN, PARTIAL, HASH, ANONYMIZE, AGGREGATE)</li>
                        <li><strong>County Restrictions:</strong> SUPERVISOR, CASE_WORKER, PROVIDER, RECIPIENT can only access their county's data</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h3>üìÅ Output Formats & Delivery</h3>
                    <ul>
                        <li><strong>JSON:</strong> Streaming format, written incrementally, no memory accumulation</li>
                        <li><strong>CSV:</strong> Streaming format, encrypted before SFTP delivery</li>
                        <li><strong>PDF:</strong> Collected in memory, generated with iText, attached to email</li>
                        <li><strong>Email Delivery:</strong> PDF attachment via SMTP (MailHog for testing)</li>
                        <li><strong>SFTP Delivery:</strong> Encrypted CSV files uploaded to /reports/daily/{date}/{county}/</li>
                        <li><strong>API Response:</strong> JSON response with download link and job status</li>
                    </ul>
                </div>

                <div class="code-block">
<span class="code-comment">// Example: Job Creation Flow</span>
<span class="code-keyword">public</span> <span class="code-class">String</span> <span class="code-function">queueReportJob</span>(<span class="code-class">BIReportRequest</span> request, <span class="code-class">String</span> jwtToken) {
    <span class="code-comment">// 1. Generate unique job ID</span>
    <span class="code-class">String</span> jobId = <span class="code-string">"JOB_"</span> + <span class="code-class">UUID</span>.<span class="code-function">randomUUID</span>().<span class="code-function">toString</span>().<span class="code-function">substring</span>(0, 8);
    
    <span class="code-comment">// 2. Create job entity</span>
    <span class="code-class">ReportJobEntity</span> job = <span class="code-keyword">new</span> <span class="code-class">ReportJobEntity</span>(jobId, request);
    job.<span class="code-function">setStatus</span>(<span class="code-string">"QUEUED"</span>);
    job.<span class="code-function">setJwtToken</span>(jwtToken);
    
    <span class="code-comment">// 3. Save to database</span>
    jobRepository.<span class="code-function">save</span>(job);
    
    <span class="code-keyword">return</span> jobId;
}

<span class="code-comment">// Example: Job Processing Flow</span>
<span class="code-keyword">public void</span> <span class="code-function">processJob</span>(<span class="code-class">String</span> jobId) {
    <span class="code-comment">// 1. Load job from database</span>
    <span class="code-class">ReportJobEntity</span> job = jobRepository.<span class="code-function">findByJobId</span>(jobId);
    
    <span class="code-comment">// 2. Extract JWT and build request</span>
    <span class="code-class">String</span> jwtToken = job.<span class="code-function">getJwtToken</span>();
    <span class="code-class">PipelineExtractionRequest</span> request = <span class="code-function">createExtractionRequest</span>(job);
    
    <span class="code-comment">// 3. Process in chunks (streaming)</span>
    <span class="code-class">String</span> resultPath = <span class="code-function">processDataInChunksStreaming</span>(request, job, jwtToken);
    
    <span class="code-comment">// 4. Mark as completed</span>
    jobQueueService.<span class="code-function">setJobResult</span>(jobId, resultPath);
}
                </div>

                <div class="info-box">
                    <h3>‚è±Ô∏è Timing & Performance</h3>
                    <ul>
                        <li><strong>Polling Interval:</strong> BatchJobScheduler polls every 5 seconds (configurable)</li>
                        <li><strong>Max Jobs Per Poll:</strong> Configurable limit (default from BatchSchedulerProperties)</li>
                        <li><strong>Chunk Size:</strong> Default 1000 records per chunk (configurable per job)</li>
                        <li><strong>Retry Logic:</strong> 3 retry attempts per chunk with exponential backoff (1s, 2s, 3s)</li>
                        <li><strong>Progress Updates:</strong> Updated after each chunk (real-time progress tracking)</li>
                        <li><strong>Memory Management:</strong> Streaming file writing prevents OutOfMemoryError</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h3>üîó Job Dependencies</h3>
                    <ul>
                        <li><strong>Parent-Child Relationship:</strong> Dependent jobs have parentJobId set</li>
                        <li><strong>Automatic Triggering:</strong> Dependent jobs queued automatically when parent completes</li>
                        <li><strong>Independent Processing:</strong> Dependent jobs process independently, don't affect parent status</li>
                        <li><strong>Configuration:</strong> Dependencies configured in JobDependencyConfig</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#667eea',
                primaryTextColor: '#fff',
                primaryBorderColor: '#5568d3',
                lineColor: '#667eea',
                secondaryColor: '#764ba2',
                tertiaryColor: '#f8f9fa'
            }
        });

        function showDiagram(diagramId) {
            // Hide all diagrams
            document.querySelectorAll('.diagram-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Show selected diagram
            document.getElementById(diagramId).classList.add('active');
            
            // Update nav buttons
            document.querySelectorAll('.nav button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }
    </script>
</body>
</html>

